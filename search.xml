<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Solution to agc063b &quot;Insert 1, 2, 3, ...&quot;</title>
      <link href="/2023/08/31/Solution-to-agc063b-Insert-1-2-3/"/>
      <url>/2023/08/31/Solution-to-agc063b-Insert-1-2-3/</url>
      
        <content type="html"><![CDATA[<p>Our goal is to assign a “predecessor” $p_i$ to each $i$ with $A_i &gt; 1$ such that</p><ul><li>$1 \le p_i &lt; i$</li><li>$A_{p_i} = A_i - 1$</li><li>all the intervals $\{ [p_i, i] \}$ do not intersect with each other.</li></ul><p>One can easily check that a sequence is generatable iff there is a valid $\{p_i\}$, with $p_i$ actually standing for “the element immediately to the left of $A_i$ when $A_i$ is just inserted”.</p><blockquote><p>To be rigorous, for any $A_i &gt; 1$, let’s consider the time it was inserted (say, we inserted $(1, 2, \cdots A_i, \cdots k)$ into some position of original sequence): 1) the intervals of previous insertions are either completely disjoint with these $k$ elements, or include these $k$ elements altogether (and hence does not intersect with $[p_i, i]$). 2) later insertions would be either disjoint with $[p_i, i]$, or included by $[p_i, i]$ completely. <strong>This is because we always add a new sequence between two adjacent existing elements</strong>, but intersection implies some other segment extends on both sides of some $p_i$ (or $i$), which would never happen. So a generatable sequence always results in a valid $\{p_i\}$.</p><p>On the other hand, consider this process: find the largest (and the right-most among the largest) element $A_i$, eleminate elements $\{A_i, A_{p_i}, A_{p_{p_i}}, \cdots , A_{q} = 1\}$, and repeat until whole sequnce is empty. Each sequence $\{A_i, A_{p_i}, A_{p_{p_i}}, \cdots , A_{q} = 1\}$ we eliminated corresponds to a sequence inserted at some step of generation. Then, to obtain the precise order of the steps, as the intervals $\{ [p_i, i] \}$ do not intersect, it’s possible to construct a tree where father interval includes son intervals, and any order that puts father in front of sons will do.</p></blockquote><p>The second observation is that, if $\{ A_1, A_2, \cdots A_n \}$ is generatable, then $\{ A_1, A_2, \cdots A_{n-1} \}$ is also generatable. Just leave $\{p_i\}$ for $\{A_i \}$ unchanged would do the proof.</p><p>Another important observation is that, if there is a valid $\{ p_i \}$, there is always a “maximum” $\{ p_i \}$ s.t. for any $j$ and any other valid $\{ p_i’ \}$, we know $p_j \ge p_j’$ always holds. We’ll prove this by recursively construct this maximum $\{ p_i \}$.</p><blockquote><p>Let’s prove this by induction for $i = 1, 2, \cdots n$. The boundary case is trivial. Assume we’ve got maximum possible $\{ p_1, p_2, \cdots p_{i - 1} \}$ already. Now we calculate the maximum possible value of $p_i$ on condition that $p_{\le i-1}$ fixed to our previously calculated “maximum” $\{ p_{\le i-1}\}$, and we’ll see this restriction is not going to make the result worse: any possible $\{ p’_{\le i-1} \}$ is no larger at every position than $\{ p_{\le i-1} \}$, so any $p_i$ valid for $\{ p’_{\le i-1} \}$ (which means $p_i  &lt; p’_{&gt; p_i}$) would also be valid for $\{ p_{\le i-1}\}$ as $p_i &lt; p’_{ &gt; p_i} \le p_{&gt; p_i}$. So the restriction to $\{ p_{\le i-1} \}$ has no effect on the maximum value of $p_i$. The maximum $p_i$ with fixed $\{ p_{\le i-1} \}$ would just be the maximum $p_i$ among all valid ways of assignment.</p><p>In this way we can always find the maxixmum $\{p_i\}$, so it always exists.</p></blockquote><p>Thus, in order to check existence, we only need to see if we can work out this maximum $\{ p_i \}$, which can be easily done with greedy algorithm. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(A[i]!=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">while</span>(!stack.<span class="built_in">empty</span>() &amp;&amp; A[stack.<span class="built_in">back</span>()] != A[i] - <span class="number">1</span>) stack.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">if</span>(!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">p[i] = stack.<span class="built_in">back</span>();</span><br><span class="line">stack.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> p[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> p[i] = i;</span><br><span class="line"><span class="comment">// cout &lt;&lt; i &lt;&lt; &quot;, p[i] = &quot; &lt;&lt; p[i] &lt;&lt;endl;</span></span><br><span class="line">stack.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And, from the process of this greedy algorithm, one can see that to run the algorithm “starting from <code>i=1</code>“ or “starting from <code>i=k</code> for some $k$” wouldn’t affect the value of $p_i$ except for the $p_i &lt; l$ terms (they’ll become 0). So we only need to run this greedy algorithm once for interval $[1, n]$, and the $\{ p_i\}$ we obtained can be used to check validity of all intervals, where the criteria is just “all $p_i$ stay within the interval”.</p><p>The counting can be accelerated to $O(n)$ complexity by various methods.</p><div class='spoiler collapsed'>    <div class='spoiler-title'>        code    </div>    <div class='spoiler-content'>        <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> A[N], n;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> UnionFind &#123;</span><br><span class="line"><span class="type">int</span> fa[N], sz[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) fa[i] = i, sz[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">un</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span>(x != y) fa[x] = y, sz[y] += sz[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Qsz</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sz[<span class="built_in">find</span>(x)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; A[i];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(A[i]!=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">while</span>(!stack.<span class="built_in">empty</span>() &amp;&amp; A[stack.<span class="built_in">back</span>()] != A[i] - <span class="number">1</span>) stack.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">if</span>(!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">p[i] = stack.<span class="built_in">back</span>();</span><br><span class="line">stack.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> p[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> p[i] = i;</span><br><span class="line"><span class="comment">// cout &lt;&lt; i &lt;&lt; &quot;, p[i] = &quot; &lt;&lt; p[i] &lt;&lt;endl;</span></span><br><span class="line">stack.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">UnionFind::<span class="built_in">init</span>();</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> vis[N];</span><br><span class="line"><span class="type">static</span> vector&lt;<span class="type">int</span>&gt; a[N];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) a[p[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=n; l&gt;=<span class="number">1</span>; --l) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i : a[l]) &#123;</span><br><span class="line">vis[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(vis[i<span class="number">-1</span>]) UnionFind::<span class="built_in">un</span>(i, i<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(vis[i+<span class="number">1</span>]) UnionFind::<span class="built_in">un</span>(i, i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(A[l] == <span class="number">1</span>) &#123;</span><br><span class="line">ans += UnionFind::<span class="built_in">Qsz</span>(l);</span><br><span class="line"><span class="comment">// cout &lt;&lt; l &lt;&lt; &quot; : &quot; &lt;&lt; UnionFind::Qsz(l) &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> OI/ACM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Matrix Tree Theorem</title>
      <link href="/2023/04/13/Matrix-Tree-Theorem/"/>
      <url>/2023/04/13/Matrix-Tree-Theorem/</url>
      
        <content type="html"><![CDATA[<h2 id="What-the-Theorem-Says"><a href="#What-the-Theorem-Says" class="headerlink" title="What the Theorem Says"></a>What the Theorem Says</h2><p><a href="https://en.wikipedia.org/wiki/Kirchhoff%27s_theorem">refer to wikipedia</a></p><p>For a directed graph, its <strong>Laplacian matrix</strong> is defined to be $L = D - A$, where $D$ is diagonal matrix of outdegree of vertices, $A$ is the adjacency matrix. Note that we assume there is no loops in this graph (if there is, deleting loops doesn’t affect number of spanning trees).</p><p>By definition one can see $L$ has the property that all rows sum up to $0$ and all columns sum up to $0$. ==this is true only when $G$ is undirected. When $G$ is undirected, only rows will sum up to $0$==</p><p>Denote the minor of $L$ that derived by deleting $i$-th row and $j$-th column by $L_{\hat i, \hat j}$. Matrix tree theorem tells that the number of oriented spanning trees rooted at vertex $i$ is $\det L_{\hat i, \hat i}$. This term ‘oriented spanning trees’ here only includes trees with edges going from father to sons, which are sometimes called out-going spanning trees (and conversely, trees with edges going from sons to father are called inner-going spanning trees).</p><p>With this theorem, we can count the number of spanning trees in undirected graphs by changing edge $u-v$ to $\{u \to v, v \to u \}$ and picking arbitrary vertex as root. Moreover, with property of Laplacian matrix, one can show $\det L_{\hat i, \hat j}$ are all equal (including those $i \neq j$).</p><p>Another result given by this theorem is that the number of spanning trees in undirected graph equals to $\frac{1}{n}\lambda_1\lambda_2 \cdots \lambda_{n-1}$, where $\lambda_1\ge \lambda_2 \ge \cdots \ge \lambda_{n-1} &gt; \lambda_n = 0$ are eigenvalues of $L$.</p><h2 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h2><h3 id="det-L-hat-i-hat-i-with-PIE"><a href="#det-L-hat-i-hat-i-with-PIE" class="headerlink" title="$\det L_{\hat i, \hat i}$ with PIE"></a>$\det L_{\hat i, \hat i}$ with PIE</h3><p><a href="https://zhongyuwei.github.io/2020/04/17/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86%E5%8F%8A%E8%AF%81%E6%98%8E/">refer to this note</a></p><p>An important corollary is that in general, let $D_{i, i} = \sum_j A_{i, j}$, then </p>$$\det L_{\hat i, \hat i} = \sum_{\text{tree T rooted at i }} \prod_{(u \to v) \in  T} A_{u, v}$$<p>Here tree $T$ is arbitrary oriented tree with vertices corresponding to row and column indices of $A$ and $L$. In the original problem, $\prod A_{u, v}$ is $0$ if $T$ contains edges not in $G$.</p><p>This generalized result suggests we can change $A_{i, j}$ to objects in some integral domain, i.e. having $A_{i, j}$ be generating functions.</p><h3 id="det-L-hat-i-hat-i-with-Cauchy-Binet"><a href="#det-L-hat-i-hat-i-with-Cauchy-Binet" class="headerlink" title="$\det L_{\hat i, \hat i}$ with Cauchy-Binet"></a>$\det L_{\hat i, \hat i}$ with Cauchy-Binet</h3><h4 id="directed-graph"><a href="#directed-graph" class="headerlink" title="directed graph"></a>directed graph</h4><p>Consider a signed version of incidence matrix:</p>$$(B^+)_{v, e} = \begin{cases}1 & \text{e is from v}\\-1 & \text{e is to v}\\0 & \text{otherwise}\end{cases}\\(B^-)_{v, e} = \begin{cases}1 & \text{e is from v}\\0 & \text{e is to v}\\0 & \text{otherwise}\end{cases}\\$$<p>Then one can check that the Laplacian matrix $L = B^+ (B^-)^T$. Also, $L_{\hat 1, \hat 1} = C^+(C^-)^T$ where $C^+=B^+_{\hat 1, .}, C^-= B^-_{\hat 1 , .}$.</p><p>Then by Cauchy Binet theorem</p>$$\det L_{\hat 1, \hat 1} = \sum_{I\in \binom{|E|}{n-1}} \det C^+_{., I} \cdot \det C^-_{I, .}$$<p>Now we claim that $(\det C^+_{., I} \cdot \det C^-_{I, .})$ is $(\pm 1)^2 = 1$ when the edges in $I$ forms an oriented tree rooted at $1$ and is 0 otherwise. Proof is as follows</p><blockquote><p>When there is a circle, $C^+_{., I}$ have linearly dependent rows (correspond to vertices in the circle), so $\det = 0$</p><p>$\det B^-_{I, .} \neq 0$ guarantees that for every vertex $v$, the outdegree is not 0. And since there are only $n-1$ edges and they form no circles, the graph must be a tree.</p></blockquote><p>Thus$\det L_{\hat 1, \hat 1}$ is number of directed spanning trees rooted at vertex 1.</p><h4 id="undirected-graph"><a href="#undirected-graph" class="headerlink" title="undirected graph"></a>undirected graph</h4><p>We can simply see undirected edge $u - v$ as two directed edges $\{ u \to v, v \to u\}$ and apply the result for directed graph.</p><p>However, there is yet another (probably simpler) way to construct $B^{\pm}$: we just arbitrarily assign direction to the edges, and $B^+ B^-$ still equals to $L$.</p><h3 id="eigenvalues-of-L"><a href="#eigenvalues-of-L" class="headerlink" title="eigenvalues of $L$"></a>eigenvalues of $L$</h3><h4 id="pf-with-similar-transformation"><a href="#pf-with-similar-transformation" class="headerlink" title="pf with similar transformation"></a>pf with similar transformation</h4><p>For Laplacian matrix $L$, consider similar transformation with ${n\times n}$ matrix $P$ where</p>$$P_{i,j} = \begin{cases}1 & i = n \text{ or } i = j\\0 & \text{otherwise}\end{cases}$$<p>Let $L = \left[ \begin{array}{c:c:c:c:c}  \\v_1 &amp; v_2 &amp; \cdots &amp; v_n \ \\\hdashline  a_1 &amp; a_2 &amp; \cdots &amp; a_n\end{array} \right]$ ($v_i$ is $(n-1)\times 1$ matrix and $a_i$ is just a number).</p><p>Since all columns and rows of $L$ respectively sum up to 0, $L’ = P L P^{-1}$ will just give us</p>$$L'= \left[\begin{array}{c:c}\\v_1 - v_n & v_2 - v_n & \cdots & v_{n-1} - v_n & v_n\\\\\hdashline0 & 0 & \cdots & 0 & 0\end{array}\right]$$<p>Eigenvalues of $L’$ are same as that of $L$ since they are similar.</p><p>Moreover, consider the characteristic polynomials of $L’$ and $L’_{(n-1)\times (n-1)}$, then one can see that $\det (L’ - \lambda I ) = (-\lambda) \cdot \det (L’_{(n-1)\times (n-1)} - \lambda I)$. Thus, assuming we know the eigenvalues of $L’$ are $\lambda_1 \ge \lambda_2 \cdots \ge \lambda_{n-1} &gt; \lambda_n  = 0$ (assume we know $\lambda_{n-1} &gt; 0$), then the eigenvalues of $L’_{(n-1)\times (n-1)}$ are just $\lambda_1, \cdots \lambda_{n-1}$, so $\lambda_1 \cdots \lambda_{n-1} = \det L’_{(n-1)\times (n-1)}$</p><p>Now try calculate $\det L’_{(n-1)\times (n-1)}$ by hand:</p>$$\begin{aligned}&\lambda_1 \cdots \lambda_{n-1} \\&=   \det L'_{(n-1)\times (n-1)}\\&=  \det \begin{bmatrix} v_1 - v_n & v_2 - v_n & \cdots & v_{n-1} - v_n \end{bmatrix}\\&= \det \begin{bmatrix} n \cdot (-v_n) & v_2 - v_n & \cdots & v_{n-1} - v_n\end{bmatrix}\\&=n \cdot \det \begin{bmatrix} (-v_n) & v_2 - v_n & \cdots & v_{n-1} - v_n\end{bmatrix}\\&= n \cdot \det \begin{bmatrix} (-v_n) & v_2 & \cdots & v_{n-1}\end{bmatrix}\\&= n \cdot \det \begin{bmatrix}v_1 & v_2 & \cdots & v_{n-1}\end{bmatrix}\end{aligned}$$<p>Note that $L_{\hat n, \hat n}$ is just $\begin{bmatrix} v_1 &amp; v_2 &amp; \cdots &amp; v_{n-1} \end{bmatrix}$. So $\frac{1}{n} \lambda_1 \cdots \lambda_{n-1} = \det L_{\hat n, \hat n}$. </p><p>==for directed graph, $\lambda_1 \cdots \lambda_{n-1}$ is just number of all rooted spanning trees, or $\sum_{i=1}^n L_{\hat i, \hat i}$==</p><h4 id="pf-with"><a href="#pf-with" class="headerlink" title="pf with"></a>pf with</h4>]]></content>
      
      
      <categories>
          
          <category> Notes on Combinatorics </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Group Theory (notes on Gallian&#39;s textbook)</title>
      <link href="/2023/04/05/Group-Theory-notes-on-Gallian-s-textbook/"/>
      <url>/2023/04/05/Group-Theory-notes-on-Gallian-s-textbook/</url>
      
        <content type="html"><![CDATA[<p>Reference: Contemporary Abstract Algebra by Gallian, ch2-11.</p><p>Following is my hand-written summary on these 10 chapters.</p><span id="more"></span><div class="pdf-container" data-target="/files/Group-Theory-notes-on-Gallian-s-textbook/Summary-GroupTheory.pdf" data-height="500px"></div>]]></content>
      
      
      <categories>
          
          <category> Notes on Abstract Algebra </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Asymptotic Behavior of Number of Partitions</title>
      <link href="/2023/03/14/Asymptotic-Behavior-of-Number-of-Partitions/"/>
      <url>/2023/03/14/Asymptotic-Behavior-of-Number-of-Partitions/</url>
      
        <content type="html"><![CDATA[<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><ul><li>OGF of partition of $n$ into at most $k$ parts: $p_{\le k}(n) = \prod_{i=1}^k \frac{1}{1 - z^i}$</li><li>Our goal is to analyse the aymptotic behavior of the coefficient of $z^n$ when $n \to \infty$ with fixed $k$.</li></ul><h2 id="Rewrite-with-Poles"><a href="#Rewrite-with-Poles" class="headerlink" title="Rewrite with Poles"></a>Rewrite with Poles</h2><ul><li><p>We can rewrite $p_{\le k}(n)$ into the form $\prod_{j=1}^k \prod_{l =1}^j \frac{1}{z - e^{2\pi i \cdot \frac{l}{j}}} = \prod_{j=1}^{k}\prod_{l \in [1,j], l\perp j} \frac{1}{\left(z - e^{2\pi i \cdot \frac{l}{j}}\right)^{\lfloor \frac{k}{j} \rfloor} } $. Those roots of unity are called poles with multiplicities.</p></li><li><p>Recall that we can write such a rational function as $p_{\le k}(n)$ as $\sum_{z_0 \text{ is a pole}, r \le \text{multiplicity}} \frac{c_{r, z_0}}{(z - z_0)^r}$ where $c$ is a constant</p></li><li><p>Now analyse the behavior of some specific $\frac{c}{(z - z_0)^r}$:</p><ul><li>$$  \begin{gather*}  c \cdot (z - z_0)^{-r} = \sum_{n=0}^\infty c \binom{-r}{n}(-z_0)^{-r - n} z^n\\  = \sum_{n=0}^\infty c (-1)^{n}\binom{n + r - 1}{r - 1} (-z_0)^{- r - n} z^n  \end{gather*}$$</li><li><p>Because $|z_0| = 1$, it is of no significance for asymptotic analysis</p></li><li>Note that $\binom{n + r - 1}{r - 1}$ is actually a $r$-degree polynomial of $n$, $c(z)$ is a polynomial with $\le r$ degree.</li></ul></li><li><p>Then, for asymptotic behavior of $p_{\le k}(n)$, we only care about the term with biggest $r$, which is $c(1 - z)^{-k}$</p></li></ul><h2 id="Determine-Asymptotic-Behavior"><a href="#Determine-Asymptotic-Behavior" class="headerlink" title="Determine Asymptotic Behavior"></a>Determine Asymptotic Behavior</h2><ul><li>$p_{\le k } ( z) = \frac{c_{k, 1}}{(1 - z)^k} + O\left(( 1 - z)^{-(k-1)}\right)$, as coefficients in $(1-z)^{-(k-1)}$ are of no asymtotic importance.</li><li>To calculate $c_{k, 1}$, consider $\left. (1 - z)^k p_{\le k(z)} \right|_{z = 1} = c_{k, 1}$, and $LHS = \prod_{i=1}^k \frac{1 - z}{1 - z^i} = \prod_{i=1}^k \frac{1}{1 + z + \cdots + z^{i-1}}$, take $z = 1$ we get $c_{k, 1} = \frac{1}{k!}$</li><li>Thus $[x^n] p_{\le k}(z) \sim c_{k, 1}\binom{n+k-1}{k-1} = \frac{1}{k!} \cdot \frac{n^{k-1}}{(k-1)!}$</li></ul><h2 id="Cor"><a href="#Cor" class="headerlink" title="Cor"></a>Cor</h2><ul><li>Number of partitions of $n$ into exactly $k$ parts, $p_k (n) \sim p_{\le k}(n) \sim \frac{n^{k-1}}{k! (k-1)!}$<ul><li>consider $p_k(n) = p_{\le k}(n) - p_{\le k-1}(n) \sim p_{\le k}(n)$</li><li>or, we may also apply the same method as analysis above, and get the same result (omitted).</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Notes on Combinatorics </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Formal Power Series: Concepts and Operations</title>
      <link href="/2023/03/10/Formal-Power-Series-Concepts-and-Operations/"/>
      <url>/2023/03/10/Formal-Power-Series-Concepts-and-Operations/</url>
      
        <content type="html"><![CDATA[<blockquote><p>view the Chinese version of this article on zhihu.com: <a href="https://zhuanlan.zhihu.com/p/611762702">1</a>, <a href="https://zhuanlan.zhihu.com/p/611820941">2</a>, <a href="https://zhuanlan.zhihu.com/p/611829272">3</a></p><p>reference:</p><ul><li>Appendix 2, <em>A Course in Combinatorics</em> by Lint Wilson</li></ul></blockquote><h2 id="Definitions-and-Notations"><a href="#Definitions-and-Notations" class="headerlink" title="Definitions and Notations"></a>Definitions and Notations</h2><h3 id="Formal-Power-Series-Addition-Multiplication"><a href="#Formal-Power-Series-Addition-Multiplication" class="headerlink" title="Formal Power Series, Addition, Multiplication"></a>Formal Power Series, Addition, Multiplication</h3><p>Consider the set $\mathbb C^{\mathbb N_0} := \{(a_0, a_1, \cdots ) \mid \forall i \in \mathbb N_0, a_i \in \mathbb C\}$.</p><p>Let’s say two elements $\mathbf a = (a_0, a_1, \cdots ), \mathbf b = (b_0, b_1, \cdots ) \in \mathbb C^{\mathbb N_0}$ are <strong>equal</strong> iff $\forall i \in \mathbb N_0, a_i = b_i$.</p><p>Define <strong>addition</strong> as $\mathbf a + \mathbf b = (a_0 + b_0, a_1 + b_1, a_2 + b_2, \cdots )$. Define <strong>multiplication</strong> as $\mathbf a \cdot \mathbf b = (c_0, c_1, \cdots )$ where $c_n = \sum_{i=0}^n a_i b_{n-i}$.</p><p>Speaking of algebraic structure, this set is actually an integral domain with unity be $(1, 0, 0, \cdots )$ (and this can be immediately seen from the properties illustrated below). But this is not important and it’s possible not to use any conclusions in abstract algebra in the following proofs, which is what I’ll do in this article.</p><p>Consider the notation $z := (0, 1, 0, 0, \cdots )$. By definition of multiplication we have $z^n = (0,0, \cdots 0, 1, 0, \cdots )$ where there are $n$ leading 0s before the 1, and $z^0$ be the multiplicative identity $(1, 0, 0, \cdots )$. It follows that $(a_0, a_1, a_2 \cdots ) = a_0 + a_1z + a_2z^2 + \cdots = \sum_{i=0}^\infty a_i z^i$, the latter being most renowned notation for <strong>formal power series</strong>.</p><p>Formally speaking, we define a <strong>formal power series</strong> to be a specific element in $\mathbb C^{\mathbb N_0}$, denoted by $\mathbf a = (a_0, a_1, a_2, \cdots )$ or $a(z) = \sum_{i=0}^\infty a_i z^i$. We denote the set of all formal power series by $\mathbb C[[z]]$.</p><p>Note that this notation looks just like polynomials and our definition of multiplication and addition consists with that on polynomials.</p><p>We have only defined addition and multiplication of finite number of formal power series. <strong>Addition and multiplication of infinite number of formal power series</strong> are allowed if for any finite $n$, the coefficients of $z^n$ in the result can be written as sum of finite non-zero terms; in other words, we don’t allow <em>addition of infinite non-zero terms</em> (as the limit doesn’t always exist). For example, $\sum_{i=0}^\infty (1 + z)^i$ is illegal because the constant of the result is infinite 1s adding together; however $\prod_{i=0}^\infty (1 + z^{i} + z^{2i} + \cdots )$ is legal. Moreover, <strong>composition of two formal power series</strong> $f(g(z)) = \sum_{i=0}^\infty f_i (g(z))^i$ is allowed iff constant of $g(z)$ is 0.</p><p>In addition, we define the <strong>order</strong> of a formal power series as $d(\mathbf a) = \min \{ k \mid k \in \mathbb N_0, a_k \neq 0 \}$.</p><h3 id="Multiplicative-Inverse"><a href="#Multiplicative-Inverse" class="headerlink" title="Multiplicative Inverse"></a>Multiplicative Inverse</h3><p>Is the multiplication on formal power series invertible? In fact, we’ll see multiplicative inverse of $\mathbf a$ exists iff $a_0 \neq 0$, and is unique if it exists at all.</p><p>Define the <strong>multiplicative inverse</strong> of a formal power series $\mathbf a$ be formal power series $\mathbf b$ that satisfies $\mathbf a \mathbf b = 1 = (1, 0, 0, \cdots )$.</p><ul><li>If $a_0 = 0$, it easily follows that for any $\mathbf b$, $(\mathbf a \mathbf b)_0 = 0 \neq 1$, so $\mathbf a$ is irreversible.</li><li>If $a_0 \neq 0$, we can get a unique recursive expression of $\mathbf b$ immediately from the definition, namely $b_0 = \frac{1}{a_0}, b_n = - a_0^{-1} \sum_{i=1}^n a_ib_{n-i}$, so $\mathbf a^{-1}$ exists and is unique.</li></ul><h3 id="Quotient-Field-and-Laurent-Series"><a href="#Quotient-Field-and-Laurent-Series" class="headerlink" title="Quotient Field and Laurent Series"></a>Quotient Field and Laurent Series</h3><p>The “quotient field of formal power series” is actually the set (actually it’s a field) of quotients of formal power series, formally defined as follows:</p><p>Consider the set $F = \{ \frac{a(z)}{b(z)} \mid a(z), b(z) \in \mathbb C[[z]]\}$ and define</p><ul><li>equivalence relation: we say two elements $\frac{a(z)}{b(z)}, \frac{c(z)}{d(z)}$ are <strong>equal</strong> iff $a(z) d(z) = b(z)c(z)$.</li><li>multiplication: $\frac{a(z)}{b(z)} \cdot \frac{c(z)}{d(z)} = \frac{a(z)c(z)}{b(z) d(z)}$</li><li>addition: $\frac{a(z)}{b(z)} + \frac{c(z)}{d(z)} = \frac{a(z)d(z) + b(z) c(z)}{b(z) d(z)}$</li></ul><p>For a invertible formal power series $b(z)$, note that $\frac{a(z)}{b(z)} = \frac{a(z) (b(z))^{-1}}{1}$ by definition.</p><p>Now consider Laurent series $p(z) = \sum_{n=k}^\infty a_nz^n$ where $k \in \mathbb Z, a_k \neq 0$. Note that a Laurrent series must be in $F$ because</p><ul><li>when $k \ge 0$, $p(z) = \frac{p(z)}{1} \in F$</li><li>when $k &lt; 0$, $p(z) = \frac{\sum_{n=0}^\infty a_{n+k} z^n}{z^{-k}} \in F$</li></ul><p>Further more, we can actually say that any element in $F$ can be represented as a Laurent series:</p><ul><li>An observation is that if $a(z)$ is formal power series, $\frac{a(z)}{z^m}$ would then be a Laurent series.</li><li>For $\frac{a(z)}{b(z)}$, let $m = d(\mathbf b)$, then obviously $\frac{b(z)}{z^m}$ is invertible and $\frac{a(z)}{b(z)} = \frac{\frac{a(z)}{x^m}}{\frac{b(z)}{x^m}} = \frac{a(z) \cdot (\frac{b(z)}{z^m})^{-1}}{z^m}$ is Laurent series.</li></ul><p>Moreover, define the <strong>residue</strong> of a Laurent series $b(z)$ be the coefficient of $z^{-1}$, denoted by $Res(b(z))$.</p><h2 id="Derivative"><a href="#Derivative" class="headerlink" title="Derivative"></a>Derivative</h2><p>For formal  power series $f(z) = \sum_{n=0}^\infty f_n z^n$, define its derivative $(Df)(z) = f’(z) = \sum_{n=0}^\infty f_{n+1}(n+1) z^n$. One can see this definition consists with that on polynomials.</p><p>We’ll prove the following rules for calculating derivative of formal power power series:</p><ol><li>$(f(z) + g(z))’ = f’(z) + g’(z)$</li><li>$(f(z)g(z))’ = f’(z)g(z) + g’(z)f(z)$</li><li>$f^k(z) = kf^{k-1}(z)f’(z)$</li><li>$(f(g(z)))’ = f’(g(z))\cdot g’(z)$</li></ol><p>pf 1.: omitted.</p><p>pf 2.: $(f(z) g(z) )’ = \sum_{i\ge0, j\ge 0, i+j&gt;0} f_ig_j (i+j)z^{i+j-1}$ and $f’(z)g(z) + g’(z)f(z) = (\sum_{i &gt; 0, j\ge 0} f_ig_j\cdot i \cdot  z^{i+j- 1}) + (\sum_{i\ge 0, j &gt; 0} f_i g_j \cdot j \cdot z^{i+j-1}) = \sum_{i\ge 0, j\ge 0, i+ j &gt; 0}f_i g_j (i+j)z^{i+j-1} =(f(z)g(z))’$</p><p>pf 3.: see $f^k(z)$ as $f(z) \cdot f(z) \cdot \cdots$ and by applying rule 2. we are done.</p><p>pf 4.: $(f(g(z)))’ = (\sum_{i=0}^\infty f_i g^i(z))’ = \sum_{i=0}^\infty f_i  \cdot i \cdot g^{i-1}(z) \cdot g’(z) = f’(g(z)) g’(z)$</p><blockquote><p>remark: Up to now, we have shown the addition, multiplication, composition and derivative on formal power series all consist with that on polynomials. This means we can often write a formal power series as “the Taylor series of some function”, which is called the closed form of this formal power series. Operations of the above 4 types on this function is equivalent to operations on its Taylor series, so operations on the closed form (obeying the same rules as corresponding numerical functions) are equivalent to operations on formal power series. This is very useful in some problems.</p></blockquote><h2 id="Exponential-and-Logarithm"><a href="#Exponential-and-Logarithm" class="headerlink" title="Exponential and Logarithm"></a>Exponential and Logarithm</h2><p>Define $\exp (z): = \sum_{n=0}^\infty \frac{z^n}{n!}, \log (1 + z) := \sum_{n=1}^\infty (-1)^n \frac{z^n}{n}$. In this context, $\exp(z), \log (1 + z)$ are defined to be two very special formal power series, and they actually possesses similar properties as the exponential function and logarithm function do, which are</p><ol><li>$\frac{1}{\exp(z)} = \exp(-z)$</li><li>$(\exp(x))^k = \exp(kx), k\in \mathbb Z^+$</li><li>$D(\exp(z)) = \exp (z)$</li><li>$D(\log (1 + z) )=\frac{1}{1 + z}$</li><li>$\log(\exp (z) ) = z$</li></ol><p>pf 1.: $\exp(z) \cdot \exp(-z) = (\sum_{n=0}^\infty \frac{x^n}{n!}) (\sum_{n=0}^\infty (-1)^n \frac{x^n}{n!}) = \sum_{n=0}^\infty \frac{x^n}{n!} \sum_{i=0}^n \binom{n}{i} (-1)^i = 1$</p><p>pf 2.: $(\exp(z))^k = \sum_{n = 0}^\infty \frac{z^n}{n!}\sum_{i_1 + i_2 + \cdots i_k = n, i_t \ge 0}  \binom{n}{i_1, i_2, \cdots i_k} = \sum_{n=0}^\infty \frac{z^n}{n!} \cdot k^n = \sum_{n = 0}^ \infty \frac{(zk)^n }{n!} = \exp(kz)$</p><p>pf 3. and 4.: Omitted (just follow the definition!)</p><p>pf 5.: Because $D(\log (\exp(z))) = D\log (\exp z) \cdot D \exp (z) = \frac{1}{\exp z} \cdot \exp z = 1$, we know $[z^1] (\log (\exp(z))) = 1,[z^n] (\log (\exp(z))) = 0(n&gt;0)$ and by definition we know constant in $\log (\exp(z)) = 0$.</p><h2 id="Inverse-Function"><a href="#Inverse-Function" class="headerlink" title="Inverse Function"></a>Inverse Function</h2><p>Define composition of two formal power series $f, g$ to be $(f \circ g) (z) = f(g(z)) := \sum_{i=0}^\infty f_i (g(z))^i$. By definition you see composition is associative.</p><p>For two formal power series $f(z), g(z)$ with zero coefficient for $z^0$ and non-zero coefficient for $z^1$, if $f(g(z)) = z$, we say $f(z)$ is the <strong>inverse function</strong> of $g(z)$, or the inverse in the sense of function composition. This inverse has two very good properties:</p><ol><li>For any $g(z)$ with zero coefficient for $z^0$ and non-zero coefficient for $z^1$, this inverse exists and is unique.<ol><li>pf: Let’s try to find such $f$. Obviously $f_1 = \frac{1}{g_1}$; expand $f\circ g$ by definition we have $0 = [z^n] f(g(z)) = f_1 \cdot ([z^n]g(z)) + f_2 ([z^n]g^2(z)) + \cdots + f_n ([z^n]g^n(z)) $. Thus, $f_n$ can always be uniquely determined through recursion.</li></ol></li><li><p>This inverse is symmetric. In other words, $f(g(z))  = z \Leftrightarrow g(f(z)) = z$.</p><ol><li>pf: Let the unique inverse of $f(z)$ be $g_1(z)$. Then $(f \circ g ) ( z) = z \Rightarrow (g_1 \circ f \circ g ) ( z) = g_1(z) \Rightarrow ((g_1 \circ f ) \circ g)(z) = g_1(z) \Rightarrow (Id \circ g(z)) = g_1(z) \Rightarrow g(z) = g_1(z)$.</li></ol><p>Next, we’ll introduce a method to calculate inverse of a formal power series efficiently.</p></li></ol><h3 id="Important-Lemma"><a href="#Important-Lemma" class="headerlink" title="Important Lemma"></a>Important Lemma</h3><p>Let $w(z)$ be a Laurent series. We claim that</p><ol><li>$Res(w’(z)) = 0$<ol><li>it follows immediately by definition of derivative.</li></ol></li><li>$Res(w’(z)/w(z)) = d(w(z))$, where $d(w(z))$ stands for the order of $w(z)$<ol><li>$\frac{w’(z)}{w(z)} = \frac{1}{z^k}\cdot \frac{\sum_{n=k-1}^\infty (n+1) w_{n+1}z^{n}}{\sum_{n=0}^\infty w_{n+k}z^n} = \frac{1}{z^k} \cdot (\sum_{n=k-1}^\infty (n+1)w_{n+1}z^n) \cdot (\sum_{n=0} w_{n+k}z^n)^{-1}$, the term with the smallest degree on the RHS is exactly $\frac{1}{z^k} \cdot (k w_k z^{k-1}) \cdot (w_k)^{-1} = k \cdot z^{-1}$.</li></ol></li></ol><h3 id="Lagrange-Inversion-Theorem"><a href="#Lagrange-Inversion-Theorem" class="headerlink" title="Lagrange Inversion Theorem"></a>Lagrange Inversion Theorem</h3><p>Here we’ll use a bit idea of Lagrange inversion theorem and the special case of the complete conclusion.</p><p>Let $W(z) = \sum_{i=0}^\infty  w_iz^i$ be a formal power series with zero coefficient for $z^0$ and non-zero coefficient for $z^1$, $Z(w) = c_1w + c_2 w^2 + \cdots$ be another formal power series and $Z(W(z)) = z$. We claim that $c_n = Res(\frac{1}{nW^n(z)})$.</p><p>pf:</p><ol><li>For $n = 1$, $c_1 = w_1^{-1} = Res(\frac{1}{W(z)})$</li><li>For $n &gt; 1$,<ol><li>Consider $D(Z\circ W)$, we have $1 = \sum_{i=0}^\infty c_{i+1} \cdot (i+1) \cdot W^{i} (z) W’(z) \Rightarrow \frac{1}{W^{n}(z)} = \sum_{i=0}^\infty c_{i+1}(i+1) W^{i-n}(z)W’(z)$.</li><li>Calculate residue on both side:<ol><li>LHS: $Res(\frac{1}{W^n(z)})$</li><li>RHS: When $i \neq n-1$, the term can be seen as derivative of $const \cdot W^{i-n+1}$, which has residue 0 by lemma above; for $i = n-1$, the residue is $c_{n} \cdot n \cdot Res(\frac{W’(z)}{W(z)}) = c_n \cdot n$</li></ol></li><li>It follows that $Res(\frac{1}{W^n(z)}) = c_n \cdot n \Rightarrow c_n = Res(\frac{1}{n W^n(z)})$</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Notes on Combinatorics </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bijection Between Real Numbers and Complex Numbers</title>
      <link href="/2023/03/09/Bijection-Between-Real-Numbers-and-Complex-Numbers/"/>
      <url>/2023/03/09/Bijection-Between-Real-Numbers-and-Complex-Numbers/</url>
      
        <content type="html"><![CDATA[<blockquote><p> reference: </p><ul><li><a href="https://www.reddit.com/r/askscience/comments/6opvae/simplest_proof_that_r2_r/">an answer on reddit.com</a></li><li><a href="https://math.byu.edu/~bakker/M341/Lectures/Lec06.pdf">a lecture note, found with google search</a></li></ul><p>Some proofs are done by myself and might be faulty.</p></blockquote><h2 id="Discussion-on-Uniqueness-of-Decimal-Expansion"><a href="#Discussion-on-Uniqueness-of-Decimal-Expansion" class="headerlink" title="Discussion on Uniqueness of Decimal Expansion"></a>Discussion on Uniqueness of Decimal Expansion</h2><ul><li>Assume a real number $x$ has two different decimal expansion $N.d_1d_2\cdots$ and $N.d_1’d_2’ \cdots$, with $d_1 = d_1’, \cdots d_{k-1} = d_{k-1}’ , d_k &gt; d_k’$<ul><li>if $d_k &gt; d_k’ + 1$, then even with $d_{k+1} = d_{k+2} = \cdots = 0$ and $d_{k+1}’=d_{k+2}’ = \cdots =9$ the difference between the two decimal expansion would still be $10^{-k}$ and they can’t possibly represent the same real number $x$.</li><li>if $d_k = d_k’ + 1$, the only way to make the two expansions equal is to have $d_{k+1} = d_{k+2} = \cdots = 0$ and $d_{k+1}’ = d’_{k+2} = \cdots = 9$. This implies $x$ is rational and the denominator is a divisor of $10^k$.</li></ul></li><li>Thus, we get to the conclusion that $x$ has 2 different decimal presentations iff $x$ is rational and the only primes that divide the denominator are 2 or 5.</li></ul><h2 id="Construct-the-bijection-between-mathbb-C-and-mathbb-R"><a href="#Construct-the-bijection-between-mathbb-C-and-mathbb-R" class="headerlink" title="Construct the bijection between $\mathbb C$ and $\mathbb R$"></a>Construct the bijection between $\mathbb C$ and $\mathbb R$</h2><p>One can see that $\mathbb R \approx \mathbb Z \times [0, 1)$ (consider the isomorphism $\phi: x \mapsto ([x], x - [x])$). Then $\mathbb C \approx \mathbb R^2  \approx \mathbb Z^2 \times [0, 1)^2 \approx \mathbb Z \times [0, 1)^2$. This means if we can find some bijection $f$ between $[0, 1)^2$ and $[0,1 )$ then we are done.</p><p>Consider the decimal expansion for $(x, y) \in [0, 1)^2$ where $x = 0.d_1d_2 \cdots, y = 0.c_1c_2\cdots$. A naive construction of $f$ is</p>$$f: (0.d_1d_2d_3 \cdots, 0.c_1c_2c_3\cdots )\mapsto 0.d_1c_1d_2c_2d_3c_3\cdots$$<p>However, this mapping is not well-defined, as it maps $(0.0999999999\cdots , 0), (0.1, 0)$ to different numbers although they are essentially the same point. The problem arises from the 2 different decimal presentations of the same number. From previous discussion, we know infinitely repeating 9 is the only case that this construction fails.</p><p>What if we add a constraint that, if there are multiple representations possible, we only use the $000 \cdots$ version to calculate the image of $f$? (You can also choose $99999\cdots$ version, and use $0$ as “marker” in the next paragraph. Here I take just $000\cdots$ for illustration) This will make $f$ well-defined and injective, but still not surjective, because numbers such as $0.0909090909 \cdots$ will have no preimage. </p><p>Note that the problem with $f^{-1}$ is essentially that, it could map a decimal expansion without repeating 9 to an expansion containing repeating 9. What about, instead of working with discrete digits, we work with digit blocks that never end with 9? For example, $0.32394999799099992\cdots$ would be seen as $0.(3)(2)(3)(94)(9997)(990)(9992)\cdots$, and $f(0.(3)(993)(0), 0.(4)(93)(92)) = 0.(3)(4)(993)(93)(0)(92)$. In this way the image contains infinitely repeating 9 iff its preimage does and vice versa. Then with the limitation that we only use $00000\cdots$ (instead of $99999\cdots$) version of decimal presentation, $f$ turns out a well-defined bijection and we’re done.</p>]]></content>
      
      
      <categories>
          
          <category> Notes on Supplementary Reading </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/07/hello-world/"/>
      <url>/2023/03/07/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="subtitle"><a href="#subtitle" class="headerlink" title="subtitle"></a>subtitle</h2><h3 id="subsubtitle"><a href="#subsubtitle" class="headerlink" title="subsubtitle"></a>subsubtitle</h3><p>formula <code>[](</code> fails for hexo-mathjax, but <code>[] (</code> is fine, like $[z^1] (F\circ G)(z)$.</p>$$\begin{gather*}\int_0^a f(x) dx\\f'(x) = \{\mathbf{a}\} \wedge \mathbb  R^n\\\mathrm {xyz}\\\begin{bmatrix}\end{bmatrix} \begin{Bmatrix} \end{Bmatrix} \begin{pmatrix} \end{pmatrix} \begin{vmatrix}\end{vmatrix} \begin{Vmatrix}\end{Vmatrix}\\\cdots \ddots \vdots\\\begin{array}{|c|cc}1 & 2 & 3\\\hline3 & 4 & 5 \\6 & 7 & 8\end{array}\\b \equiv a\pmod p\\\nabla, \Re, \aleph\\\prec, \cong, \sim, \approx\\\star, \ast, \bullet, \circ\\\lnot, \neg, \vdash, \vDash\\\varnothing, \emptyset, \supset, \subseteq, \subseteqq \setminus\end{gather*}$$<p>inline formula: $f(x) \in \mathcal L(A, B)$.</p><p>中文字可以正常显示。</p><h2 id="中文子标题"><a href="#中文子标题" class="headerlink" title="中文子标题"></a>中文子标题</h2><p>test pdf:</p><div class="pdf-container" data-target="/files/test/test-pdf-GEM053.pdf" data-height="500px"></div><p>test image:</p><p><img src="/img/test/test-image.png" alt=""></p><p>（本地用<code>../img/test/test-image.png</code>就可以在本地正常看见</p><p>或者用图床：</p><p><a href="https://www.linkpicture.com/view.php?img=LPic6408b6167c7cd1203070296"><img src="https://www.linkpicture.com/q/test-image.png" alt="image"></a></p>]]></content>
      
      
      <categories>
          
          <category> test my blog </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
